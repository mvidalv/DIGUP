#!usr/bin/python#Mireia Vidal#python v2.7#####python pop2_opt.py pigs_fas2.txt -i 12 8 8 8 6 -n 42 -o 1 -s -inc -Gimport timeimport argparseimport sysimport osimport reimport mathimport randomimport pdbstart_time = time.clock()#Argumentsparser = argparse.ArgumentParser(description='Pop analysis test v.1.0') parser.add_argument('-i', metavar='I', type=int, nargs='+', required=True,    help="Total number of individuals for each population, last population is considered the outgroup (Required)") parser.add_argument('-n', required=True,    help="Total number of sequences (Required)") parser.add_argument('-o', choices=("1", "2" ,"12"), required=False,	help="Classification output type (1/2/12)")		parser.add_argument('-ms', action="store_true" ,	help="Input file in ms format")parser.add_argument('-l', metavar='W', type=int,    help="in case of ms file, lentgh of the sequences")    parser.add_argument('-nt', metavar='P', type = int, nargs='+', required=False,	help="Total number of individuals if Pool-seq (out-group not needed)")	#parser.add_argument('-T', action="store_true" ,#    help="CHECK TRESS")parser.add_argument('-G', action="store_true" ,    help="Get Fragments visualisation .png format")    parser.add_argument('filename',    help="input file") #parse argumentsargs = parser.parse_args()myfile = args.filenameind = args.iseq_num = args.nout_type = args.oif args.o == None:	out_type = 1wsiz = args.lpool = args.nt################Open filetry:  my_file = open(myfile)except (IOError):  print "Error: could not open the file. Try again."  sys.exit(0)#List sequences without headerdef get_seqs():	#ms format	win_size = [0]	wind_size = []	posis = []	trees= []	if (args.ms): 		dict = ['0', '1']		#List sequences without header		my_seqs = []		my_seqs_w = []		f = open(myfile)		d = open(myfile)		hed = d.readline()		hed = hed.rstrip(os.linesep)		header = f.readline()		header = header.rstrip(os.linesep)			header_list = []		nao = 0		siz = 0		ws = 0		mypos = []		myposi = []		wind_size = []		trees = []		for linies in d:			linies = linies.rstrip('\n')			# if args.T: #get trees from ms# 				if re.search('^\[', linies):# 					thetree = linies.split(']')# 					trees.append(thetree)# 				trees_t = []			if re.search('^positions', linies): #get positions				thepos = linies.split()				thepos = thepos[1:]				mypos.append(thepos)				thepos= []		for x in xrange(len(mypos)): #make positons real positions			for y in xrange(len(mypos[x])):				flute = float(mypos[x][y])				toapnd = int(round(flute * wsiz, 1) + (x * wsiz))				if toapnd in posis[-10:]: #if two positions are the same, jump to next position (for ms test)					jump = 1					toapnd = int(round(flute * wsiz, 1) + (x * wsiz) + jump)					while toapnd + jump in posis[-10:-1]: 						jump = jump + 1						toapnd = toapnd + jump					posis.append(toapnd)				else:					posis.append(toapnd)			siz = siz + wsiz			wind_size.append(siz)		for line in f:			line = line.rstrip('\n')			if re.search('//', line): #if multiple windows in ms format				my_seqs_w.append(my_seqs)				my_seqs = []				nao = 1				win_size.append(ws + win_size[-1])				ws = 1			elif re.search('^[0-9]', line) and nao ==1: #get sequences				my_seqs.append(line)				ws = len(line)		my_seqs_w.append(my_seqs)		my_seqs_w = my_seqs_w[1:]		sequence=''			my_seqs= []		my_seqs_pop = []		for i in range(len(my_seqs_w[0])):			for n in range(len(my_seqs_w)):				sequence += my_seqs_w[n][i]			my_seqs.append(sequence)			sequence = ''		win_size.append(ws + win_size[-1])		win_size = win_size[2:]		d.close()	#fasta format	else: 		dict = ['A', 'C', 'G', 'T']		my_seqs = []		seqsApnd = my_seqs.append		f = open(myfile)		header = f.readline()		header = header.rstrip(os.linesep)		sequence=''		for line in f: #get sequences			line = line.rstrip('\n')			if(line.startswith( '>' )):				header = header[1:]				header = line				seqsApnd(sequence)				sequence = ''				else:				sequence += line.upper()		seqsApnd(sequence)	# if args.T: #get trees from ms# 		for itm in xrange(len(trees)):# 			for num in xrange(len(trees[itm])):# 				trees[itm][num] = trees[itm][num][1:]	f.close()	return my_seqs, dict, win_size, posis, wind_size, trees	my_seqs, dict, win_size, posis, wind_size, trees = get_seqs()################################################### get_seqs() output ################################################################################my_seqs = sequences in list		 																												##dict = depending if is ms format or fasta, will be nucleotides or 0, 1. Everything not in the list will be considered missing data (ej: N or 8)	##win_size = deprecated, now is wind_size																											##posis = real positions considering the real length for the ms format																				##wind_size = for knowing real length of the sequences in ms format																					##trees = knowing positions for each tree 																											######################################################################################################################################################def get_pops(): #List populations with sequences pop_seqs[pop_number][ind_number][nucleotide]	start = 0	pop_seqs = []	popseqApnd = pop_seqs.append	no_out = ind[:-1] #exclude outgroup sequences	for i in no_out:		end = start + i		popseqApnd(my_seqs[start:end])		start = start + i	lenpop = len(pop_seqs) # quantes poblacions hi ha	lenseq = len(pop_seqs[0][0]) # llargada de les sequencies (de cada individu, que han de ser iguals)	lenind = ind[0:-1] #nombre d individus a cada poblacio (ougrup exclos)	print lenpop, lenseq, lenind	return pop_seqs, lenpop, lenseq, lenind	pop_seqs, lenpop, lenseq, lenind = get_pops()def out_seq(): #List outgroup sequences	out = ind[-1]	out_seqs = []	for i in range(out):		i = i + 1		out_seqs.append(my_seqs[-i])	return out_seqsout_seqs = out_seq()def warnings(): #Check arguments - warnings	len_seq = len(my_seqs)	varLen0 = len(my_seqs[0])	if seq_num == len_seq:		print "Error: Total number of sequences is not correct. Check -n argument"		sys.exit(0)	sum_ind = sum(ind)	if sum_ind != len_seq:		print "Error: Total number of sequences does not match with total number of individuals. Check -i argument", "total number of individuals introduced:",sum_ind, "total number of individuals", len_seq		sys.exit(0)		for sequence in xrange(len_seq):		if len(my_seqs[sequence]) != varLen0:			print "Error: Sequences does not have the same length"			sys.exit(0)				if out_type in ['2'] and args.ms:		print "Error: Cannot generate output type 2 with ms format because nucleotides are unknown"		sys.exit(0)			if out_type in ['12'] and args.ms:		print "Warning: Ouput type 2 won't be generated"		sys.exit(0)warnings()my_seqs = [] #ja no necessito aquesta llistaprint time.clock() - start_time, "warnings check"#get file name without extensionmyfile_name = ""for i in myfile:	if i == ".":		break	else:		myfile_name = myfile_name + "".join(i)def ancestrals(): #check multiple ancestral	#m_ancest = []	m_opts = []	m_an_list = []	out_nucl = []	lenOut = len(out_seqs)	lenOut0 = len(out_seqs[0])	n_cont = 0	manlistApnd = m_an_list.append	moreout = []	#If 2 or less outgroups make a fast preparation:	if lenOut == 1:		for x in xrange(lenOut):			print x, lenOut			m_an_list.extend(out_seqs[x])			for nucl in out_seqs[x]:				if nucl not in dict:					n_cont = n_cont + 1 #count unknown nucleotides in outgrup		m_an_list = map(list,m_an_list)	#If outgrup individuals = 2, make a fast preparation:	elif lenOut == 2: 		for outgroup in xrange(1, lenOut):			for nucleotide in xrange(lenOut0):				outVar = out_seqs[outgroup][nucleotide]		 		outVar0 = out_seqs[0][nucleotide]				if outVar != outVar0:					if outVar in dict:						m_opts.append(str(outVar))					if outVar0 in dict:						m_opts.append(str(outVar0))					elif outVar not in dict and outVar0 not in dict: #If we have different undetermined nucleotides (N,R,M,Y....)						m_opts.append("N") #Just append "-" as it contains different undetermined nucleotides						n_cont = n_cont + 1					out_nucl = m_opts				else: #If we have the same nucleotides (undetermined or not)					if outVar not in dict:						n_cont = n_cont + 1 #count unknown nucleotides in outgrup					out_nucl.append(outVar0) #Just append one of them (they are the same nucleotides)				manlistApnd(out_nucl)				m_opts = []					out_nucl = []	#If ougrup individuals > 2	else:		mopts = ""		for nucleotide in xrange(lenOut0):			contout = 1			out0done = 0			outVar0 = out_seqs[0][nucleotide]			for outgroup in xrange(1,lenOut):				outVar = out_seqs[outgroup][nucleotide]							if outVar != outVar0:					if outVar in dict and outVar not in out_nucl:						out_nucl.extend(str(outVar))						contVar = outVar					if outVar0 in dict and out0done !=1:						out0done = 1						out_nucl.extend(str(outVar0))					elif outVar not in dict and outVar0 not in dict:						contout = contout + 1						if contout == lenOut:							out_nucl.extend("N")							n_cont = n_cont + 1 #count unknown nucleotides in outgrup									elif out0done != 1 and outVar0 in dict:					out_nucl.extend(str(outVar0))					out0done = 1					contout = contout + 1				else:					contout = contout + 1					if outVar not in dict and contout == lenOut:						n_cont = n_cont + 1	 #count unknown nucleotides in outgrup						out_nucl.extend("N")									manlistApnd(out_nucl)			m_opts = []				mopts = ""			out_nucl = []	return out_nucl, m_an_list, n_contout_nucl, m_an_list, n_cont = ancestrals()	print time.clock() - start_time, "check multiple ancestral"####################### GET INFO output "Results_" type I #########################def out_1():	count = 1	d_count = 0	d_count_list = []	d_count_list_pop = []	indeter = 0	total_list = []	total_list_pop = []	info_list  = []	info_list_pop = []	mult_check = []	lenPop = len(pop_seqs)	infopopApnd = info_list_pop.append	totalApnd = total_list_pop.append	dlistApnd = d_count_list_pop.append	infolistApnd = info_list.append	dcountApnd = d_count_list.append	nns = []	for populations in xrange(lenPop):		print "I'm at ", populations, " population ",time.clock() - start_time		lenNucl = len(pop_seqs[populations][0])		lenInd = len(pop_seqs[populations])		for nucleos in xrange(lenNucl):			individuals = 1			first_ind = 0			Ind1 = pop_seqs[populations][first_ind][nucleos]			anVar = m_an_list[nucleos]			mult_hit = 0			while individuals < lenInd:					IndG = pop_seqs[populations][individuals][nucleos] 				if Ind1 in dict:					if IndG not in dict:						individuals = individuals + 1						count = count + 1					elif IndG != Ind1:						Ind10 = Ind1						for indiv in xrange(lenInd):							IndG2 = pop_seqs[populations][indiv][nucleos]							if IndG2 not in dict:								pass							elif IndG2 not in anVar:								d_count = d_count + 1								if IndG2!=Ind10 and Ind10 not in anVar:									mult_hit = 1								Ind10 = IndG2						dcountApnd(d_count)						d_count = 0						if len(anVar) != 1:							infolistApnd("m")						elif anVar[0] not in dict:							infolistApnd("N")						elif mult_hit == 1:							infolistApnd("M")									else:							infolistApnd("P")												individuals = lenInd					else:						individuals = individuals + 1						count = count + 1				else:					first_ind = first_ind + 1					Ind1 = pop_seqs[populations][first_ind][nucleos]					individuals = individuals + 1					count = count + 1			if count == lenInd:				if Ind1 not in anVar:					indeter = 0					for individ in xrange(lenInd):						IndG3 = pop_seqs[populations][individ][nucleos]						if IndG3 not in dict:							indeter = indeter + 1						elif IndG3 not in anVar:							d_count = d_count + 1					d_count_list.append(d_count)					d_count = 0					if len(anVar) != 1:						infolistApnd("m")					elif anVar[0] not in dict:						infolistApnd("N")					elif (lenInd - indeter) == 0:						infolistApnd("U")					else:						infolistApnd("D")				else:					d_count_list.append(d_count)					if len(anVar) != 1:						infolistApnd("m")					elif anVar[0] not in dict:						infolistApnd("N")					elif (lenInd - indeter) == 0:						infolistApnd("U")					else:						infolistApnd("A")			indeter = 0			for individuals in xrange(lenInd):				if pop_seqs[populations][individuals][nucleos] not in dict:					indeter = indeter + 1			count = 1			total_list.append(lenInd - indeter)			indeter = 0		infopopApnd(info_list)		info_list = []		infolistApnd = info_list.append			totalApnd(total_list)		total_list = []		dlistApnd(d_count_list)		d_count_list = []		dcountApnd = d_count_list.append	 	return d_count_list_pop, total_list_pop, info_list_pop def get_pos():	print "I'm getting positions to print at Classification_1", time.clock() - start_time	#get positions to print	test = zip(*info_list_pop)	lenTest = len(test)	set_pos = []	posApnd = set_pos.append	for i in xrange(lenTest):		TestI = test[i]					if TestI.count("A") == lenpop or "N" in TestI or "U" in TestI:			pass		else:			posApnd(i)		return set_pos, test	def p_out_1():		set_pos, test = get_pos()	print "I'm going to print the first output Classification_1_...", time.clock() - start_time	#print info in output file	myout = "Classification_1_" + myfile_name + "_" + time.strftime("%d%m%Y") + ".txt"	fo = open(myout, "w")	new_list = []	print >>fo, "D:derived A:ancestral P:polymorphic m:multiple ancestral M:multiple derived N:unknown ancestral U:unknown nucleotide in population"	print >>fo, "\nname\tposition\t[A/D/P]\t#D\t#Total"	print >>fo, "\t\t\t" + "\t\t\t".join("pop[" + str(x) + "]" for x in range(len(pop_seqs)))	p = 0	realpos = []	for positions in set_pos:		if (args.ms):			posit = posis[positions]		else:			posit = positions		for item in xrange(len(info_list_pop)):			new_list_temp ="".join(str(info_list_pop[item][positions]) + "\t" + str(d_count_list_pop[item][positions]) + "\t" + str(total_list_pop[item][positions]))			new_list.append(new_list_temp)		print >>fo, str(myfile)  + "\t" + str(posit +1) + "\t" + "\t".join(str(x) for x in new_list)		new_list = []	fo.close()	return realpos, testif out_type in ['1', '12']:	d_count_list_pop, total_list_pop, info_list_pop = out_1()	realpos, test = p_out_1()	print time.clock() - start_time, "out 1 done"######### output type 2 ###########def out_2():	a1_count_tmp = []	c_count_tmp = []	t_count_tmp = []	g_count_tmp = []	a1_count = []	c_count = []	t_count = []	g_count = []	a1 = 0	c = 0	t = 0	g = 0	a_stat = []	g_stat = []	c_stat = []	t_stat = []	lenPop = len(pop_seqs)	for populations in xrange(lenPop):		lenInd0 = len(pop_seqs[populations][0])		lenInd = len(pop_seqs[populations])		for nucleos in xrange(lenInd0):			anVar = m_an_list[nucleos]				for individus in xrange(lenInd):				Ind = pop_seqs[populations][individus][nucleos]				a1 = a1 + Ind.count("A")				c = c + Ind.count("C")				t = t + Ind.count("T")				g = g + Ind.count("G")				if anVar[0] not in dict:					a_stat_tmp ="N"					c_stat_tmp ="N"					t_stat_tmp ="N"					g_stat_tmp ="N"			else:					if "A" in anVar:					a_stat_tmp = "A"				else:					a_stat_tmp = "D"				if "C" in anVar:					c_stat_tmp = "A"				else:					c_stat_tmp = "D"				if "T" in anVar:					t_stat_tmp = "A"				else:					t_stat_tmp = "D"				if "G" in anVar:					g_stat_tmp = "A"				else:					g_stat_tmp = "D"			a1_count_tmp.append(str(a1) + str(a_stat_tmp))			c_count_tmp.append(str(c) + str(c_stat_tmp))			t_count_tmp.append(str(t) + str(t_stat_tmp))			g_count_tmp.append(str(g) + str(g_stat_tmp))			a1 = 0			c = 0			t = 0			g = 0			a_stat_tmp = ""			g_stat_tmp = ""			c_stat_tmp = ""			t_stat_tmp = ""			a1_count.append(a1_count_tmp)		c_count.append(c_count_tmp)		t_count.append(t_count_tmp)		g_count.append(g_count_tmp)		a1_count_tmp = []		c_count_tmp = []		t_count_tmp = []		g_count_tmp = []	return a1_count, c_count, t_count, g_count#summarydef out_2_s():	sum2 = []	summ = []	summ_pop = []	sum_comb = ""	sum_comb_cas = []	info_list_pop = []	salta = 0	chk_u = 0	lena1 = len(a1_count)	for pop in xrange(lena1):		lena1_p = len(a1_count[pop])		a1_pop = a1_count[pop]		c_pop = c_count[pop]		t_pop = t_count[pop]		g_pop = g_count[pop]		for i in xrange(lena1_p):			if len(m_an_list[i]) != 1:				sum2.append("m")			else:				if a1_pop[i][0] != '0':					sum2.append(a1_pop[i][-1])					chk_u = 1					if c_pop[i][0] != '0':					sum2.append(c_pop[i][-1])					chk_u = 1									if t_pop[i][0] != '0':					sum2.append(t_pop[i][-1])					chk_u = 1				if g_pop[i][0] != '0':					sum2.append(g_pop[i][-1])					chk_u = 1				if chk_u != 1:					sum2.append("U")			chk_u = 0			summ.append(sum2)			sum2 = []		summ_pop.append(summ)		summ = []	lenSum = len(summ_pop)	for pop in xrange(lenSum):		lenSum_p = len(summ_pop[pop])		for case in xrange(lenSum_p):			sum_c = summ_pop[pop][case]			lensumC = len(sum_c)			if lensumC != 1:				if sum_c.count('D') > 1:					sum_comb = "M"				elif sum_c.count('N') != 0:					sum_comb = "N"				else:					for n in range(1,lensumC):						if sum_c[n] != sum_c[0]:							sum_comb = "P"							salta = 1					if salta != 1:				 		sum_comb = (str(sum_c[0]))			else:				sum_comb = str(sum_c[0])			sum_comb_cas.append(sum_comb)			sum_comb = ""			salta = 0		info_list_pop.append(sum_comb_cas)		sum_comb_cas = []			return info_list_pop	#print info in output filedef p_out_2():	set_pos, test = get_pos()		myout = "Classification_2_" + myfile_name + "_" + time.strftime("%d%m%Y") + ".txt"	new_list2 = []	fo = open(myout, "w")	print >>fo, "D:derived A:ancestral P:polymorphic m:multiple ancestral M:multiple derived N:unknown ancestral" 	print >>fo, "\nname\tposition\tA:#[A/D] C:#[A/D] T:#[A/D] G:#[A/D]"	print >>fo,"\t\t\t" + "\t\t\t\t\t".join("pop[" + str(x) + "]" for x in range(len(pop_seqs)))	lena1 = len(a1_count)	for positions in set_pos:			for item in xrange(lena1):			new_list2_tmp =("A:" + str(a1_count[item][positions]) + "\tC:" + str(c_count[item][positions]) + "\tT:" + str(t_count[item][positions]) + "\tG:" + str(g_count[item][positions]))			new_list2.append(new_list2_tmp)		print >>fo, str(myfile) + "\t" + str(positions + 1) + "\t" + "\t\t".join(str(x) for x in new_list2)		new_list2 = []	return test######### END output type 2 ###########if out_type in ['2','12'] and not args.ms:	a1_count, c_count, t_count, g_count = out_2()	info_list_pop = out_2_s()	test = p_out_2()	print time.clock() - start_time, "out 2, done"############# SUMMARY ################def summary_info(test):	my_comb_type_w = []	my_comb_count_w = []	level2 = []	total_comb = 3**lenpop	test00 = []	print time.clock() - start_time, "summary, test00 done"	comb_pos = [] #added aqui	combpos = comb_pos.append #added aqui	comb_name_w = []#added aqui	if args.ms:		my_comb_count = []		my_comb_type = []		no_comb = 0		my_M = 0		my_m = 0		#my_u = 0		my_Mc = 0		my_mc = 0		#my_uc = 0		lenTest = len(test)		combApnd = my_comb_type.append		combcntApnd = my_comb_count.append		comb_pos = []		comb_pos_name = []		combposname = comb_pos_name.append		combpos = comb_pos.append		w = 0		st = 0		comb_name_w = []		for i in xrange(lenTest):			testi = test[i]			if testi not in my_comb_type:				lentestI = len(testi)				for n in xrange(lentestI):					testIn = test[i][n]					if testIn not in ['A','P','D']:						no_comb = 1						if testIn == "M":							my_Mc = 1						elif testIn == "m":							my_mc = 1						#elif testIn == "U":						#	my_uc = 1				my_M = my_M + my_Mc				my_m = my_m + my_mc				#my_u = my_u + my_uc				my_Mc = 0				my_mc = 0				#my_uc = 0				if no_comb == 0:					combApnd(testi)					testst = test[st:win_size[w]]					combcntApnd(testst.count(testi))					combposname("".join(testi))					no_comb =  0			if w <= len(win_size) and i == win_size[w]-1:				if my_comb_type and my_comb_count:					st = win_size[w]					my_comb_type_w.append(my_comb_type)					comb_name_w.append(comb_pos_name)					comb_pos_name = []					combposname = comb_pos_name.append					my_comb_count_w.append(my_comb_count)					my_comb_type = []					my_comb_count =[]					combApnd = my_comb_type.append					combcntApnd = my_comb_count.append				else:					my_comb_type_w.append(my_comb_type)					my_comb_count_w.append(my_comb_count)				w = w + 1			comb_pos_name = my_comb_type_w					my_comb_type_w.append(my_comb_type)		my_comb_count_w.append(my_comb_count)		for k in range(len(my_comb_type_w)):			level3 = (map(list, my_comb_type_w[k]))			level2.append(level3)			level3 = []	my_comb_count = []	my_comb_type = []	no_comb = 0	my_M = 0	my_m = 0	#my_u = 0	my_Mc = 0	my_mc = 0	#my_uc = 0	lenTest = len(test)	combApnd = my_comb_type.append	combcntApnd = my_comb_count.append	comb_pos_name = []	combposname = comb_pos_name.append	for i in xrange(lenTest):		testi = test[i]		if testi not in my_comb_type:			lentestI = len(testi)			for n in xrange(lentestI):				testIn = test[i][n]				if testIn not in ['A','P','D']:					no_comb = 1					if testIn == "M":						my_Mc = 1					elif testIn == "m":						my_mc = 1					#elif testIn == "U":					#	my_uc = 1			my_M = my_M + my_Mc			my_m = my_m + my_mc			#my_u = my_u + my_uc			my_Mc = 0			my_mc = 0			#my_uc = 0			if no_comb == 0:				combApnd(testi)				combcntApnd(test.count(testi))				#Get info pos for position incompatibilities				comb_pos_t = []				combpost =comb_pos_t.append				combposname("".join(testi))				for x in range(lenTest):					if test[x] == testi:						combpost(x)				combpos(comb_pos_t)				#END Get info pos for position incompatibilities			no_comb =  0	level1 = map(list, my_comb_type)	print time.clock() - start_time, "summary ready"	test = None #ja no el necessito	return level1, my_M, my_m, total_comb, my_comb_type, my_comb_count, comb_pos_name, comb_pos, level2, my_comb_count_w, my_comb_type_w, comb_name_w, test00	def summary_print():	print "I'm going to print the summary", time.clock() - start_time	mysummary = "Summary_" + myfile_name + "_" + time.strftime("%d%m%Y") + ".txt"	su = open(mysummary, "w")	print >>su, "+-----------------+\n| GENERAL SUMMARY |\n+-----------------+"	print >>su,"Type\t#positions\n"	##### general summary ######		for i in xrange(len(level1)):		combi = ""		lenLevI = len(level1[i])		LevI = level1[i]		for n in xrange(lenLevI):			combi = "".join(combi + (str(LevI[n])))		print >>su, combi + "\t" + str(my_comb_count[i])	print >>su, "\nM\t" + str(my_M) + "\nm\t" + str(my_m) + "\nN\t" + str(n_cont)	if args.ms:		print >>su, "\nCombinations found: " + str(len(my_comb_type)+1) + "\t(AAA combination not shown but present)"+"\nPossible combinations: "  + str(total_comb) 	else:		print >>su, "\nCombinations found: " + str(len(my_comb_type)) + "\nPossible combinations: "  + str(total_comb)	print >>su, "Sequence length:",lenseq		print >>su, "\nD:derived A:ancestral P:polymorphic m:multiple ancestral M:multiple derived N:unknown ancestral"	 	##### BY WINDOWS #####	if args.ms:			t_comb_w = []		tcwApnd = t_comb_w.append		wstart = 1			for n in xrange(len(wind_size)):			lenlevel2n = len(level2[n])			wstart = wind_size[n] + 1			for i in xrange(lenlevel2n):				combi = ""				LevI = level2[n]			tcwApnd(lenlevel2n)		return t_comb_w, level2, my_comb_count_w	else:		su.close()		return	##### END BY WINDOWS ################## END SUMMARY ##################### PI AND DIVERGENCE #####def pi_k():		#get pi calc list by pops	def pi():			print "pi function", time.clock() - start_time		pi_list = []		xpop = xrange(len(pop_seqs))		for pop in xpop:			print "pi for", pop, "population"			pi_calc = 0			pos_inside = 0			xnucl0 = xrange(len(pop_seqs[pop][0]))			for nucl in xnucl0:				if args.ms:					ncont = total_list_pop[pop][nucl] #ns				else:					ncont = total_list_pop[pop][nucl]				if args.nt:					ncont = pool[pop]						if ncont > 1:					if info_list_pop[pop][nucl] != 'M':						if len(m_an_list[nucl]) < 2:							if m_an_list[nucl][0] in dict:								pairs = (ncont* (ncont-1)) / 2								d_c = d_count_list_pop[pop][nucl]								alter_d = ncont - d_c								freq_count = (alter_d * d_c) / float(pairs)								pi_calc = pi_calc + freq_count								pos_inside = pos_inside + 1								if args.ms:				pos_cont = pos_inside + (wsiz - len(pop_seqs[pop][0]))			else:				pos_cont = pos_inside			pi_calc_f = pi_calc / float(pos_cont)			pi_list.append(pi_calc_f)				return pi_list		#get divergence list by pops	def k():		print "k function", time.clock() - start_time		k_list = []		xpop = xrange(len(pop_seqs))		for pop in xpop:			print "k for", pop, "population"			k_calc = 0			pos_inside = 0			xnucl0 = xrange(len(pop_seqs[pop][0]))			for nucl in xnucl0:				ncont = total_list_pop[pop][nucl]				if args.nt:					ncont = pool[pop]					if len(m_an_list[nucl]) < 2: # outgrup no plimorphic					if m_an_list[nucl][0] in dict: #nomes tinc un outgrup (o dos pero tenen el mateix nucleotid) i el nucleotid no es unknown						if ncont > 0: # minim d'un individu sense missing a la poblacio							d_c = d_count_list_pop[pop][nucl]							pairs = ncont							freq_count = (d_c) / float(pairs)							k_calc = k_calc + freq_count							pos_inside = pos_inside + 1			if args.ms:				pos_cont = pos_inside + (wsiz - len(pop_seqs[pop][0]))			else:				pos_cont = pos_inside			k_calc_f = k_calc / float(pos_cont)			k_list.append(k_calc_f)		return k_list		pi_list = pi()	k_list = k()		print pi_list,"pi", k_list, "k"	return pi_list, k_list##### END PI AND DIVERGENCE ####pi_list, k_list = pi_k()pop_seqs = None # ja no necesito saber mes les sequenciesout_seqs = None #ja no necessito saber mes les output sequencesm_an_list = None # ja no el necessito saber mesd_count_list_pop = None # ja no el necessito saber meslevel1, my_M, my_m, total_comb, my_comb_type, my_comb_count, comb_pos_name, comb_pos, level2, my_comb_count_w, my_comb_type_w, comb_name_w, test00 =  summary_info(test)if args.ms:	t_comb_w, level2, my_comb_count_w = summary_print()else:	summary_print()info_list_pop = None # ja no el necessito saber meslevel1 = None	print time.clock() - start_time, "end summary print"def mis_values(pi1, k1, pi2, k2):	addp = round((pi1*k2) + ((1-pi1)*k2), 2)	adpp = round(((1-pi1)*k2), 2)	dapd = round((k1*pi2) + ((1-pi2)*k1), 2)	dapp = round(((1-pi2)*k1), 2)	pdda = round((k1*pi2) + ((1-pi2)*k1), 2)	dpad = round((pi1*k2) + ((1-pi1)*k2), 2)	ppad = round(((1-pi1)*k2), 2)	ppda = round(((1-pi2)*k1), 2)	dppd = round((k1*k2), 2)	pddp= round((k2*k1), 2)	mis_value = {'ADDP':addp, 'ADPP':adpp, 'DAPD':dapd, 'DAPP': dapp, 'PDDA':pdda, 'PDDP':pddp, 'DPAD':dpad, 'DPPD':dppd, 'PPAD':ppad, 'PPDA':ppda}	return mis_value############# INCOMPATIBILITY FOR POSITIONS #################def inco_pos():	print "Starting incompatible positions", time.clock() - start_time	i_comps = comb_pos_name	myincpositions = "Inc_positions_" + myfile_name + "_" + time.strftime("%d%m%Y") + ".txt"	co = open(myincpositions, "w")	#RULE I - easy cases (when they are contiguos)	ruleI = {'DA':['PD','PP'], 'AD':['DP','PP'], 'PD':['DA','DP'], 'DP':['AD','PD'], 'PP':['AD','DA']}		rII_pos = []	rI_extm = []	rI = []	lenicom = len(i_comps)	inc_n = 0	prico = 0	in_pos_a = []	in_pos_b = []	comb_posi = []	comb_posis = []	po = 0	cposisApnd = comb_posis.append	paApnd = in_pos_a.append	pbApnd = in_pos_b.append	miss_w = []	inc_poblA = []	inc_poblB = []	type_calc = []	if args.ms:		for x in xrange(len(comb_pos)):			for y in xrange(len(comb_pos[x])):				comb_posi.append(posis[comb_pos[x][y]])			cposisApnd(comb_posi)			comb_posi = []	print >>co, "+------------------------+\n| INCOMPATIBLE POSITIONS |\n+------------------------+\n"	for x in xrange(lenicom):		print "inc positions first part", x, lenicom, time.clock() - start_time		inc = 0		for n in xrange(x,lenicom):			posDi = []			posAi = []			posPi = []			posDj = []			posPj = []			posAj = []			icmpx = i_comps[x]			icmpn = i_comps[n]			if args.ms:				cmpx = comb_posis[x]				cmpn = comb_posis[n]			else:				cmpx = comb_pos[x]				cmpn = comb_pos[n]			for i, ltr in enumerate(icmpx):				if ltr == 'D':					posDi.append(i)				if ltr == 'A':						posAi.append(i)				if ltr =='P':					posPi.append(i)			for j, ltj in enumerate(icmpn):				if ltj == 'D':					posDj.append(j)				if ltj== 'P':					posPj.append(j)				if ltj == 'A':					posAj.append(j)			setAi = set(posAi)			setDi = set(posDi)			setPi = set(posPi)			setDj = set(posDj)			setPj = set(posPj)			setAj = set(posAj)			alrprint = 0			if (list(setAi & setDj) and list(setDi & setPj)):				inc_n = inc_n + 1				print >> co,"[" + str(inc_n) + "a]",icmpn,", ".join(str(y+1) for y in cmpn)				print >> co, "["+ str(inc_n) + "b]",icmpx,", ".join(str(z+1) for z in cmpx), "\n"				alrprint = 1				prico = 1				inc = 1				paApnd(cmpx)				pbApnd(cmpn)				listAD = list(setAi & setDj)				listDP = list(setDi & setPj)				inc_poblA.append(listAD)				inc_poblB.append(listDP)				type_calc.append('addp') 				miss_val = 0			elif (list(setDi & setAj) and list(setPi & setDj)):				listDA = list(setDi & setAj)				listPD= list(setPi & setDj)				miss_val = 0				inc = 1				miss_w.append(miss_val)				inc_n = inc_n + 1				print >> co,"[" + str(inc_n) + "a]",icmpn,", ".join(str(y+1) for y in cmpn)				print >> co, "["+ str(inc_n) + "b]",icmpx,", ".join(str(z+1) for z in cmpx), "\n"				inc_poblA.append(listDA)				inc_poblB.append(listPD)				type_calc.append('dpad')				alrprint = 1				prico = 1				paApnd(cmpx)				pbApnd(cmpn)			elif (list(setAi & setPj) and list(setDi & setPj)):				listAP = list(setAi & setPj)				listDP = list(setDi & setPj)				miss_val = 0				inc = 1				miss_w.append(miss_val)				inc_n = inc_n + 1				print >> co,"[" + str(inc_n) + "a]",icmpn,", ".join(str(y+1) for y in cmpn)				print >> co, "["+ str(inc_n) + "b]",icmpx,", ".join(str(z+1) for z in cmpx), "\n"				inc_poblA.append(listAP)				inc_poblB.append(listDP)				type_calc.append('adpp')				alrprint = 1				prico = 1				paApnd(cmpx)				pbApnd(cmpn)			elif (list(setPi & setAj) and list(setPi & setDj)):				listPA = list(setPi & setAj)				listPD = list(setPi & setDj)				miss_val = 0				inc = 1				miss_w.append(miss_val)				inc_n = inc_n + 1				print >> co,"[" + str(inc_n) + "a]",icmpn,", ".join(str(y+1) for y in cmpn)				print >> co, "["+ str(inc_n) + "b]",icmpx,", ".join(str(z+1) for z in cmpx), "\n"				inc_poblA.append(listPA)				inc_poblB.append(listPD)				type_calc.append('ppad')				alrprint = 1				prico = 1				paApnd(cmpx)				pbApnd(cmpn)			elif (list(setDi & setPj) and list(setPi & setDj)):				listDP = list(setDi & setPj)				listPD = list(setPi & setDj)				miss_val = 0				inc = 1				miss_w.append(miss_val)				inc_n = inc_n + 1				print >> co,"[" + str(inc_n) + "a]",icmpn,", ".join(str(y+1) for y in cmpn)				print >> co, "["+ str(inc_n) + "b]",icmpx,", ".join(str(z+1) for z in cmpx), "\n"				inc_poblA.append(listDP)				inc_poblB.append(listPD)				type_calc.append('dppd')				alrprint = 1				prico = 1				paApnd(cmpx)				pbApnd(cmpn)	if inc != 1:		rII_pos.append(x)	rII_pos = list(set(rII_pos))	#RULE II	for x in rII_pos:		print "inc positions second part", x, len(rII_pos) , time.clock() - start_time		inc = 0		for n in rII_pos:			vectAi = []			vectAj = []			vectDi = []			vectDj = []			for p in xrange(len(i_comps[n])):				p3 = p + 3				comps2 = i_comps[n][p:p3]				comps1 = i_comps[x][p:p3]				icmpx = i_comps[x]				icmpn = i_comps[n]				if args.ms:					cmpx = comb_posis[x]					cmpn = comb_posis[n]				else:					cmpx = comb_pos[x]					cmpn = comb_pos[n]				if len(comps1) == 3:					for i, ltr in enumerate(comps1):						if ltr == 'D':							vectDi.append(i)						if ltr == 'A':							vectAi.append(i)					for j, ltj in enumerate(comps2):						if  ltj == 'D':							vectDj.append(j)						if ltj == 'A':							vectAj.append(j)					if vectDi and vectDj and vectAi and vectAj:						if list(set(vectDj) & set(vectDi)):							if not list(set(vectAj) & set(vectAi)):								listD = list(set(vectDj) & set(vectDi))								inc_n = inc_n + 1								print >> co,"[" + str(inc_n) + "a]",", ".join(str(y+1) for y in cmpn)								print >>co, "["+ str(inc_n) + "b]",", ".join(str(z+1) for z in cmpx), "\n"								inc_poblB.append(listD)								inc_poblA.append(vectAi)								pi1A = pi_list[vectAi[0]]								kD = k_list[listD[0]]								pi2A = pi_list[vectAj[0]]								mis_val2 = round((kD*(1-pi1A)) * (kD*(1-pi2A)),2)								miss_w.append(mis_val2)								type_calc.append('dax')								inc = 1								prico = 1								paApnd(cmpx)								pbApnd(cmpn)								break				else:					break			if prico != 1:		inc_fragm = 0		print >>co, "No incompatible positions"	else:		inc_fragm = 1			print time.clock() - start_time, "end incomp by position"	co.close()	return in_pos_a, in_pos_b, miss_w, inc_fragm, inc_poblA, inc_poblB, type_calcmytestname = "my_test_" + myfile +  time.strftime("%d%m%Y")+ ".txt" mytest_mis = open(mytestname,"w")print >>mytest_mis, "end]\t[start\tw\tw_norm\tmising\t[nsA_1,nsB_1,nsA_1,nsB_2,ntA_1,ntB_1,ntA_2,ntB_2]\ttype"############ END INCOMPATIBILITIES BY POSITION #########################def mis_calcs(y, listabx1, listabx):	nsA_1, ntA_1, nsB_1, ntB_1 = ns_nt(y, listabx1)	nsA_2, ntA_2, nsB_2, ntB_2 = ns_nt(y, listabx)	betaA_1, betaB_1 = beta_c(nsA_1, nsB_1, y)	betaA_2, betaB_2 = beta_c(nsA_2, nsB_2, y) 	alphaA_1, alphaB_1 = alpha_c(ntA_1, ntB_1, y)	alphaA_2, alphaB_2 = alpha_c(ntA_2, ntB_2, y)	pntA_1, pntB_1 = pnt_c(ntA_1, ntB_1, y)	pntA_2, pntB_2 = pnt_c(ntA_2, ntB_2, y)	pnsA_1, pnsB_1 = pns_c(nsA_1, nsB_1, y)	pnsA_2, pnsB_2 = pnt_c(nsA_2, nsB_2, y)	pntnsA_1, pntnsB_1 = pntns_c(nsA_1, ntA_1, nsB_1, ntB_1, y)	pntnsA_2, pntnsB_2 = pntns_c(nsA_2, ntA_2, nsB_2, ntB_2, y)		addp = ((((1- alphaA_1 - pntA_1) /(1-betaA_1 - pnsA_1)) * (alphaB_1 / betaB_1)) + ((pntnsA_1 / (1-betaA_1 - pnsA_1) * (alphaB_1 / betaB_1))))- (((pntnsA_1 / (1-betaA_1 - pnsA_1)) * (alphaB_1 / betaB_1) * ((betaB_1 - alphaA_1) / betaB_1)))	dapd = ((((1- alphaA_1 - pntA_1) /(1-betaA_1 - pnsA_1)) * (alphaB_1 / betaB_1)) + ((pntnsA_1 / (1-betaA_1 - pnsA_1) * (alphaB_1 / betaB_1))))- (((pntnsA_1 / (1-betaA_1 - pnsA_1)) * (alphaB_1 / betaB_1) * ((betaB_1 - alphaA_1) / betaB_1)))		adpp = ((1- alphaA_1 - pntA_1) /(1-betaA_1 - pnsA_1)) * (alphaB_1 / betaB_1)	dapp = ((1- alphaA_1 - pntA_1) /(1-betaA_1 - pnsA_1)) * (alphaB_1 / betaB_1)		pdda = ((((1- alphaA_2 - pntA_2) /(1-betaA_2 - pnsA_2)) * (alphaB_2 / betaB_2)) + ((pntnsA_2 / (1-betaA_2 - pnsA_2) * (alphaB_2 / betaB_2))))- (((pntnsA_2 / (1-betaA_2 - pnsA_2)) * (alphaB_2 / betaB_2) * ((betaB_2 - alphaA_2) / betaB_2)))	dpad = ((((1- alphaA_2 - pntA_2) /(1-betaA_2 - pnsA_2)) * (alphaB_2 / betaB_2)) + ((pntnsA_2 / (1-betaA_2 - pnsA_2) * (alphaB_2 / betaB_2))))- (((pntnsA_2 / (1-betaA_2 - pnsA_2)) * (alphaB_2 / betaB_2) * ((betaB_2 - alphaA_2) / betaB_2)))		ppad = ((1- alphaA_2 - pntA_2) /(1-betaA_2 - pnsA_2)) * (alphaB_2 / betaB_2)	ppda = ((1- alphaA_2 - pntA_2) /(1-betaA_2 - pnsA_2)) * (alphaB_2 / betaB_2)		dppd = (alphaA_1 / betaA_1) * (alphaB_2 / betaB_2)	pddp = (alphaA_1 / betaA_1) * (alphaB_2 / betaB_2)		dax = ((1- alphaA_1 - pntA_1) /(1-betaA_1 - pnsA_1)) *  (alphaB_1 / betaB_1) * (alphaB_2 / betaB_2) * ((1- alphaA_1 - pntA_1) /(1-betaA_1 - pnsA_1))	mis_calc = {'addp':addp, 'adpp':adpp, 'dapd':dapd, 'dapp': dapp, 'pdda':pdda, 'pddp':pddp, 'dpad':dpad, 'dppd':dppd, 'ppad':ppad, 'ppda':ppda, 'dax':dax}		mis_value = (nsA_1+nsB_1+nsA_2+nsB_2) / (ntA_1+ntB_1+ntA_2+ntB_2)	all_values = [int(nsA_1),int(nsB_1),int(nsA_2),int(nsB_2),int(ntA_1),int(ntB_1),int(ntA_2),int(ntB_2)]		return mis_calc, mis_value, all_values	return mis_calc	def min_w():	addp_min_pop = []	adpp_min_pop = []	dppd_min_pop = []	dax_min_pop = []	for pop in xrange(lenpop):		ns_min = 1.0		nt_min = lenind[pop]		k_mean = k_list[pop]		pi_mean = pi_list[pop]		#derived in ns		beta_min = k_mean		#derived in nt		i_min = 2.0		alphap = 0.0		while i_min <= nt_min:			alphap = alphap +float(1/(i_min* (i_min-1)))			i_min = i_min + 1		alpha_min = k_mean - (alphap * pi_mean)		#pnt		i_min = 2.0		pntp = 0.0		while i_min <= (nt_min-1):			pntp = pntp +float(1/i_min)			i_min = i_min + 1		pnt_min = pi_mean * pntp		#pns		i_min = 2.0		pnsp = 0.0		while i_min <= (ns_min-1):			pnsp = pnsp +float(1/i_min)			i_min = i_min + 1		pns_min = pi_mean * pnsp		#pntns		i_min = ns_min		pntnsp = 0.0		while i_min <= (nt_min-1):			pntnsp = pntnsp +float(1/i_min)			i_min = i_min + 1		pntns_min = pi_mean * pntnsp				addp_min = ((((1- alpha_min - pnt_min) /(1-beta_min - pns_min)) * (alpha_min / beta_min)) + ((pntns_min / (1-beta_min - pns_min) * (alpha_min / beta_min))))- (((pntns_min / (1-beta_min - pns_min)) * (alpha_min / beta_min) * ((beta_min - alpha_min) / beta_min)))		adpp_min = ((1- alpha_min - pnt_min) /(1-beta_min - pns_min)) * (alpha_min / beta_min)					dppd_min = (alpha_min / beta_min) * (alpha_min / beta_min)					dax_min = ((1- alpha_min - pnt_min) /(1-beta_min - pns_min)) *  (alpha_min / beta_min) * (alpha_min / beta_min) * ((1- alpha_min - pnt_min) /(1-beta_min - pns_min))			addp_min_pop.append(addp_min)		adpp_min_pop.append(adpp_min)		dppd_min_pop.append(dppd_min)		dax_min_pop.append(dax_min)	addp_min = min(addp_min_pop)		dapd_min = addp_min	pdda_min = addp_min	dpad_min = addp_min		adpp_min = min(adpp_min_pop)		dapp_min = adpp_min	ppad_min = adpp_min	ppda_min = adpp_min		dppd_min = min(dppd_min_pop)		pddp_min = dppd_min		dax_min = min(dax_min_pop)	wei_min = {'addp':addp_min, 'adpp':adpp_min, 'dapd':dapd_min, 'dapp': dapp_min, 'pdda':pdda_min, 'pddp':pddp_min, 'dpad':dpad_min, 'dppd':dppd_min, 'ppad':ppad_min, 'ppda':ppda_min, 'dax':dax_min}	return wei_min	############## INCOMPATIBLE FRAGMENTS FROM POSITIONS ##################def inc_frag():	print "Starting incompatible fragments", time.clock() - start_time	myincfrag = "Inc_fragments_" + myfile_name + "_" + time.strftime("%d%m%Y") + ".txt"	allinc = "Raw_fragments_" + myfile_name + "_" + time.strftime("%d%m%Y") + ".txt"	afr = open(allinc, "w")	fr = open(myincfrag, "w")	print >>fr,  "+------------------------+\n| INCOMPATIBLE FRAGMENTS |\n+------------------------+\n"	print >>afr,  "+---------------+\n| RAW FRAGMENTS |\n+---------------+\n"	miss_wf = []	wei_min = min_w()	if args.ms or not args.ms:		leninposa = len(in_pos_a)		incfrag = []		incfApnd = incfrag.append		for y in xrange(leninposa):			inposay = in_pos_a[y]			inposby = in_pos_b[y] 			listab = inposay + inposby			listtedab = "a"*(len(in_pos_a[y])) + "b"*(len(in_pos_b[y]))			order = sorted(range(len(listab)), key=lambda k: listab[k])			listab.sort()			print "Positions sorted",y, leninposa, time.clock() - start_time			theinc = []			incApnd = theinc.append			for x in xrange(1,len(listab)):				listabx1 = listab[x-1]				listabx =listab[x]				if listtedab[order[x]] != listtedab[order[x-1]]:					incApnd(listabx1+1) # 1 based					incApnd(listabx+1) # 1 based					# A --> first population					# B --> second population					# 1 --> first position					# 2 --> second position								mis_calcu, mis_value, all_values = mis_calcs(y, listabx1, listabx)					miss_p = mis_calcu[type_calc[y]]					w_norm = round((miss_p - (wei_min[type_calc[y]])) / (1.0 - (wei_min[type_calc[y]])),2)					if w_norm > 1.0:						w_norm = 1.0					elif w_norm <= -0.0:						w_norm = 0.0					miss_p = round((miss_p),2)					print >> mytest_mis,listabx1+1, "\t", listabx+1,"\t", miss_p,"\t", w_norm, "\t", mis_value,"\t", all_values, "\t", type_calc[y], "\n"					incApnd(miss_p)					incApnd(w_norm)					incfApnd(theinc)					theinc = []					miss_wf.append(miss_p)									incApnd = theinc.append					print "I know all incompatible fragments (raw)", time.clock() - start_time		sortincfrag = sorted(incfrag, key=getKey)		sort1 = sorted(incfrag, key=getKey)		sort2 = sorted(incfrag, key=getKey2)		relop1 = 1		relop2 = 1		print "Lets check the final fragments", time.clock() - start_time		lensort1 = len(sort1)		lensort2 = len(sort2)		while relop1 < lensort1 or relop2 < lensort2:			toprint1 = []			toprint = []			relop1 = 1			relop2 = 1			nexpos = 0			i = 1			while i < lensort1:				sort1i = sort1[i]				sort1i1 = sort1[i-1]				if sort1i1[0] != sort1i[0]:					relop1 = relop1 + 1					toprint1.append(sort1i1)				else:					if (sort1i1[1]-sort1i1[0]) < (sort1i[1]-sort1i[0]):						sort1.pop(i)						nexpos = -1								else:						sort1.pop(i-1)						nexpos = -1				i = i + 1 + nexpos				nexpos= 0				lensort1 = len(sort1)			sort2 = sorted(sort1, key=getKey2)			lensort2 = len(sort2)			n = 1			nexpos = 0			while n < lensort2:				sort2n = sort2[n]				sort2n1 = sort2[n-1]				if sort2n1[1] != sort2n[1]:					relop2 = relop2 + 1				else:					if (sort2n1[1]-sort2n1[0]) < (sort2n[1]-sort2n[0]):						sort2.pop(n)						nexpos = -1					else:							sort2.pop(n-1)						nexpos = -1				n = n + 1 + nexpos				nexpos = 0				lensort2 = len(sort2)			sort1 = sorted(sort2, key=getKey)		toprint = sorted(sort2, key=getKey)		toprintcopy = sorted(sort2, key=getKey)		pospop = []		nexpos = 0		print "Still checking for the final fragments...", time.clock() - start_time		ltoprnt = len(toprintcopy)		a1 = 1		while a1 < ltoprnt:			a = a1 -1			topra = toprintcopy[a]			topra1 = toprintcopy[a1]			if topra1[0] > topra[0] and topra1[0]< topra[1]:				if topra1[1] > topra[0] and topra[1] < topra[1]:					toprintcopy.pop(a)					pospop.append(a)					nexpos = nexpos -1				else:					if (topra1[1] - topra1[0]) < (topra[1] - topra[0]):							toprintcopy.pop(a)						pospop.append(a)						nexpos = nexpos - 1					else:						toprintcopy.pop(a1)						pospop.append(a1)						nexpos = nexpos - 1			elif topra[1] > topra[0] and topra[1] < topra[1]:				if (topra1[1] - topra1[0]) < (topra[1] - topra[0]):						toprintcopy.pop(a)					pospop.append(a)					nexpos = nexpos - 1				else:					toprintcopy.pop(a1)					pospop.append(a1)					nexpos = nexpos - 1			elif topra[0] > topra1[0] and topra[0] < topra1[1]:				if topra[1] > topra1[0] and topra[1] < topra1[1]:					toprintcopy.pop(a1)					pospop.append(a1)						nexpos = nexpos - 1				else:					if (topra1[1] - topra1[0]) < (topra[1] - topra[0]):							toprintcopy.pop(a)						pospop.append(a)						nexpos = nexpos - 1					else:						toprintcopy.pop(a1)						pospop.append(a1)						nexpos = nexpos - 1						a1 = a1 + 1 + nexpos			nexpos = 0			ltoprnt = len(toprintcopy)		print len(toprint), len(toprintcopy), "len toprint, len toprintcopy"		print >>fr, "[...end]\t[start...]\tcomb1\tcomb2\tw\tw_norm\n"		print >>afr, "[...end]\t[start...]\tcomb1\tcomb2\tw\tw_norm\n"		if toprint == None:			toprint = sort1		start = 1 #1 based		if args.ms:			print len(toprintcopy), "len toprintcopy"			for i, j, k, q in toprintcopy:							print >>fr, str(i) + "\t" + str(j) + "\t" + "".join(test[posis.index(i-1)]) + "\t" + "".join(test[posis.index(j-1)]) + "\t" + str(k) + "\t" + str(q)		else:			for i, j, k, q in toprintcopy:				print >>fr, str(i) + "\t" + str(j)  + "\t" +  "".join(test[i-1]) + "\t" + "".join(test[j-1]) + "\t" + str(k) + "\t" + str(q)		#raw incompatibilities		if args.ms:			print len(sortincfrag), "len sortincfrag"			for i, j, k, q in sortincfrag:				print >>afr, str(i) + "\t" + str(j) + "\t" + "".join(test[posis.index(i-1)]) + "\t" + "".join(test[posis.index(j-1)]) + "\t" + str(k) + "\t" + str(q)		else:			for i, j, k, q in toprint:				print >>afr, str(i) + "\t" + str(j)  + "\t" +  "".join(test[i-1]) + "\t" + "".join(test[j-1]) + "\t" + str(k) + "\t" + str(q)			else:		return	sortincfrag = None #ja no el necessito	fr.close()	afr.close()	print time.clock() - start_time, "end incomp by FRAGMENTS"	#mst.close()	return toprint, toprintcopy############## END INCOMPATIBLE FRAGMENTS FROM POSITIONS ####################### print incompatible fragments#######def graph_inc():	from biograpy import Panel, tracks, features	from Bio import SeqFeature	from Bio import SeqIO, AlignIO, SeqFeature	grappng = "Graph_Fragments_" + myfile_name + "_" + time.strftime("%d%m%Y") + ".png"	if args.ms:		longi = args.l	else:		longi = lenseq	panel = Panel(xmin=1, xmax = longi +1, grid = 'both')	frag_track = tracks.BaseTrack(name = 'Fragments', cm ='Blues_r', draw_cb = True, cb_label="w")	start = 1	for x,y,j,k in toprintcopy:		location = SeqFeature.FeatureLocation(start, x)		feat = SeqFeature.SeqFeature()		feat.location = location		feat.qualifiers['score'] = 0.0		frag_track.append(features.GenericSeqFeature(feat ,use_score_for_color = True ))				location = SeqFeature.FeatureLocation(x+1, y-1)		feat = SeqFeature.SeqFeature()		feat.location = location		feat.qualifiers['score'] = k		frag_track.append(features.GenericSeqFeature(feat, use_score_for_color = True, lw = 0.0))		start = y	location = SeqFeature.FeatureLocation(start,longi + 1)	feat = SeqFeature.SeqFeature()	feat.location = location	feat.qualifiers['score'] = 0.0	frag_track.append(features.GenericSeqFeature(feat, use_score_for_color = True))	panel.append(frag_track)	panel.save(grappng)############END print incompatible fragments###########def getKey(item):    return item[0]def getKey2(item):    return item[1]def ns_nt (y, position): #GET NS AND NT FOR EACH POPULATION (A, B)	if args.ms:		nsA = float(total_list_pop[inc_poblA[y][0]][posis.index(position)])		ntA = float(lenind[inc_poblA[y][0]])		nsB = float(total_list_pop[inc_poblB[y][0]][posis.index(position)])		ntB = float(lenind[inc_poblB[y][0]])	else:		nsA = float(total_list_pop[inc_poblA[y][0]][position])		ntA = float(lenind[inc_poblA[y][0]])		nsB = float(total_list_pop[inc_poblB[y][0]][position])		ntB = float(lenind[inc_poblB[y][0]])	if args.nt:		ntA = float(pool[inc_poblA[y][0]])		ntB = float(pool[inc_poblB[y][0]])		return nsA, ntA, nsB, ntB		def beta_c(nsA, nsB, y): #DERIVED IN NS		#POP-A	iA = 2.0	betaAp = 0.0	while iA <= nsA:		betaAp = betaAp +float(1/(iA* (iA-1)))		iA = iA + 1	betaAp = betaAp * pi_list[inc_poblA[y][0]]	betaA = k_list[inc_poblA[y][0]] - betaAp	#POP-B	iB = 2.0	betaBp = 0.0		while iB <= nsB:		betaBp = betaBp +float(1/(iB* (iB-1)))		iB = iB + 1	betaBp = betaBp * pi_list[inc_poblB[y][0]]	betaB = k_list[inc_poblB[y][0]] - betaBp	return betaA, betaBdef alpha_c(ntA, ntB, y): #DERIVED IN NT		#POP-A	iA = 2.0	alphaAp = 0.0	while iA <= ntA:		alphaAp = alphaAp +float(1/(iA* (iA-1)))		iA = iA + 1	alphaAp = alphaAp * pi_list[inc_poblA[y][0]]	alphaA = k_list[inc_poblA[y][0]] - alphaAp	#POP-B	iB = 2.0	alphaBp = 0.0	while iB <= ntB:		alphaBp = alphaBp +float(1/(iB* (iB-1))) 		iB = iB + 1	alphaBp = alphaBp * pi_list[inc_poblB[y][0]]	alphaB = k_list[inc_poblB[y][0]] - alphaBp	return alphaA, alphaBdef pnt_c(ntA, ntB, y): #POLYMORPHIC IN NT	#POP-A	iA = 2.0	pntAp = 0.0	while iA <= ntA:		pntAp = pntAp +float(1/iA)		iA = iA + 1	pntA = pi_list[inc_poblA[y][0]] * pntAp	#POP-B	iB = 2.0	pntBp = 0.0	while iB <= ntB:		pntBp = pntBp +float(1/(iB-1))		iB = iB + 1	pntB = pi_list[inc_poblB[y][0]] * pntBp	return pntA, pntB	def pns_c(nsA, nsB, y): #POLYMORPHIC IN NS	#POP-A	iA = 2.0	pnsAp = 0.0	while iA <= nsA:		pnsAp = pnsAp +float(1/(iA-1))		iA = iA + 1	pnsA = pi_list[inc_poblA[y][0]] * pnsAp	#POP-B	iB = 2.0	pnsBp = 0.0	while iB <= nsB:		pnsBp = pnsBp +float(1/(iB-1))		iB = iB + 1	pnsB = pi_list[inc_poblB[y][0]] * pnsBp	return pnsA, pnsBdef pntns_c(nsA, ntA, nsB, ntB, y): #POLYMORPHIC IN NT-NS	#POP-A	iA = float(nsA)	pnsntAp = 0.0	while iA <= (ntA):		pnsntAp = pnsntAp +float(1/(iA-1))		iA = iA + 1	pnsntA = pi_list[inc_poblA[y][0]]* pnsntAp	#POP-B	iB = float(nsB)	pnsntBp = 0.0	while iB <= (ntB):		pnsntBp = pnsntBp +float(1/(iB-1))		iB = iB + 1	pnsntB = pi_list[inc_poblB[y][0]] * pnsntBp	return pnsntA, pnsntB######### check tree function ################## def check_T():# 	suma = 0# 	sumaL = []# 	print len(trees)# 	for p in xrange(len(trees)):# 		suma = suma + int(trees[p][0])# 		sumaL.append(suma)# 	for x, y, j, k in toprintcopy:# 		#realx = posis.index(x-1)# 		#realy = posis.index(y-1)# 		xdone = 0# 		ydone = 0# 		sumi = 0# 		while sumi < len(sumaL):# 			checksumi = 0# 			if sumaL[sumi] >= x and xdone != 1:# 				xdone = 1# 				#print trees[sumi][1], "for", x# 				checksumi = sumi# 			if sumaL[sumi] >= y and ydone != 1:# 				ydone = 1# 				#print trees[sumi][1], "for", y# 				if sumi == checksumi:# 					print "oh oh, same tree... for", x, y , sumaL[sumi], sumaL[sumi-1], sumaL[sumi+1]# 					#print trees[sumi][1], "for", x# 					# 				else:# 					checksumi = 0# 			if xdone != 0 and ydone != 0:# 				sumi = len(sumaL)# 			sumi = sumi + 1######### END check tree function #################		in_pos_a, in_pos_b, miss_w, inc_fragm, inc_poblA, inc_poblB, type_calc = inco_pos()if inc_fragm != 0:	level1 = None	total_comb = None 	my_comb_type = None	my_comb_count = None 	comb_pos_name = None	comb_pos = None	d_count_list_pop = None		toprint, toprintcopy = inc_frag()	# if args.T:# 		check_T()	toprint = None	total_list_pop = None	in_pos_a = None	in_pos_b = None	test00 = None	inc_poblB = None	inc_poblA = None	if args.G:		graph_inc()	else:	myincfrag = "Inc_fragments_" + myfile_name + "_" + time.strftime("%d%m%Y") + ".txt"	fr = open(myincfrag, "w")	print >>fr,  "+------------------------+\n| INCOMPATIBLE FRAGMENTS |\n+------------------------+\n"	print >>fr, "No incompatible fragments found"mytest_mis.close()time = time.clock() - start_timeprint time, "seconds"